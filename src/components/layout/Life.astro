---
import SectionTitle from "../ui/SectionTitle.astro";
import SubTitle from "../ui/SubTitle.astro";
const { id } = Astro.props;
const memories = [
  { src: "/images/life/1.jpeg", alt: "思い出1", label: "兵庫の妖怪ベンチ" },
  { src: "/images/life/2.jpeg", alt: "思い出2", label: "長野のご当地パン" },
  { src: "/images/life/3.jpeg", alt: "思い出3", label: "友達と温泉旅行" },
  { src: "/images/life/4.jpeg", alt: "思い出4", label: "夏祭り" },
];
const tape = [
  { src: "/images/life/tape1.png", className: "-rotate-6" },
  { src: "/images/life/tape2.png", className: "rotate-6" },
  { src: "/images/life/tape3.png", className: "rotate-3" },
  { src: "/images/life/tape4.png", className: "-rotate-3" },
];
---

<section id={id} data-reveal-scope="life">
  <SectionTitle text="Life" />
  <SubTitle text="奈々の思い出" />
    <div class="mt-7 mb-5">
      <div class="mx-auto flex w-full max-w-[1024px] flex-wrap justify-between px-5">
        {memories.map((item, index) => {
          const tapeItem = tape[index % tape.length];
          return (
            <div
              class="life-card relative mb-8 w-[48%] rounded-[12px] border border-text/30 bg-white p-[16px] md:mb-0 md:w-[23%]"
              data-reveal
              style={`--delay:${index * 90}ms`}
            >
              <img
                src={tapeItem.src}
                alt=""
                aria-hidden="true"
                class={`life-tape pointer-events-none absolute -top-8 left-1/2 z-10 w-[120px] -translate-x-1/2 md:w-[132px] ${tapeItem.className}`}
              />
              <div class="aspect-square overflow-hidden rounded-[4px] mb-5 pb-4">
                <img src={item.src} alt={item.alt} class="h-full w-full object-cover" />
              </div>
              <p class="mt-0 text-center text-[16px] font-chiru py-3">{item.label}</p>
            </div>
          );
        })}
      </div>
    </div>
</section>

<style>
  .life-card {
    opacity: 0;
    transform: translateY(-120px) scale(0.94);
    will-change: transform, opacity;
  }

  .life-tape {
    opacity: 0;
    transform: translateY(-50px) rotate(-10deg) scale(0.8);
    will-change: transform, opacity;
  }

  .life-card.is-visible {
    animation: life-card-in 1600ms cubic-bezier(0.23, 1, 0.32, 1) forwards;
    animation-delay: var(--delay, 0ms);
  }

  .life-card.is-visible .life-tape {
    animation: life-tape-in 1000ms cubic-bezier(0.22, 1, 0.36, 1) forwards;
    animation-delay: calc(var(--delay, 0ms) + 1400ms);
  } 

  .life-card.no-animate,
  .life-card.no-animate .life-tape {
    opacity: 1;
    transform: none;
    animation: none;
  }

  @keyframes life-card-in {
    0% {
      opacity: 0;
      transform: translateY(-120px) scale(0.94);
    }
    60% {
      transform: translateY(10px) scale(1.02);
    }
    100% {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
  }

  @keyframes life-tape-in {
    0% {
      opacity: 0;
      transform: translateY(-50px) rotate(-10deg) scale(0.8);
    }
    70% {
      transform: translateY(6px) rotate(3deg) scale(1.05);
    }
    100% {
      opacity: 1;
      transform: translateY(0) rotate(0deg) scale(1);
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .life-card,
    .life-tape {
      opacity: 1;
      transform: none;
      animation: none;
    }
  }
</style>

<script is:inline>
  const lifeSection = document.querySelector('section[data-reveal-scope="life"]');
  if (lifeSection) {
    const targets = lifeSection.querySelectorAll("[data-reveal]");
    const setVisible = (el, animate = true) => {
      el.classList.add("is-visible");
      if (!animate) el.classList.add("no-animate");
    };
    const isAbove = (el) => el.getBoundingClientRect().bottom < 0;
    const isInView = (el) => {
      const rect = el.getBoundingClientRect();
      return rect.top < window.innerHeight && rect.bottom > 0;
    };

    targets.forEach((el) => {
      if (isAbove(el)) setVisible(el, false);
    });

    if (!("IntersectionObserver" in window)) {
      targets.forEach((el) => setVisible(el, false));
    } else {
      let lastY = window.scrollY;
      const observer = new IntersectionObserver(
        (entries, obs) => {
          const currentY = window.scrollY;
          const scrollingDown = currentY >= lastY;
          lastY = currentY;
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              setVisible(entry.target, scrollingDown);
              obs.unobserve(entry.target);
            }
          });
        },
        { threshold: 0.2, rootMargin: "0px 0px -10% 0px" }
      );
      targets.forEach((el) => {
        if (window.scrollY > 0 && isInView(el)) {
          setVisible(el, false);
        } else if (!el.classList.contains("is-visible")) {
          observer.observe(el);
        }
      });
    }
  }
</script>
